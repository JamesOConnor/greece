{% extends "base.html" %}

{% load static %}

{% block js %}
    {{ block.super }}
    <div id="chart" style="width: 50%; height: 100%; float:left;">
    </div>
    <div id="mapid" style="width: 50%; height: 100%; float:right;">
    </div>

    <script>
        overlays = [];

        function sync_get(theUrl) {
            let xmlHttp = new XMLHttpRequest();
            xmlHttp.open("GET", theUrl, false); // false for synchronous request
            xmlHttp.send(null);
            return xmlHttp;
        }

        function sync_post(theUrl, data) {
            let xmlHttp = new XMLHttpRequest();
            xmlHttp.open("POST", theUrl, false); // false for synchronous request
            xmlHttp.setRequestHeader("Content-Type", "application/json");
            xmlHttp.send(JSON.stringify(data));
            if (xmlHttp.status !== 404) {
                return JSON.parse(xmlHttp.responseText);
            }
        }

        function draw_image(geoj) {
            let im = sync_post('ndvi/', geoj);
            image = L.imageOverlay("data:image/png;base64," + im['image'], JSON.parse(im['bounds']));
            image.addTo(mymap);
            return image
        }

        function make_chart(response_data, geoj, boundary) {
            const parsed = {ndvi: [], ranges: []};
            var filteredArray = _.filter(response_data, function (obj) {
                if (obj['Mean NDVI'] === "--") {
                    return obj.ignore;
                } else if (parseFloat(obj['Mean NDVI']) < 0.01) {
                    return obj.ignore;
                }
                return obj
            });

            parsed["ndvi"] = _.map(filteredArray, function (item) {
                val = parseFloat(item['Mean NDVI']);
                return [moment.utc(item.Date).valueOf(), val]
            });

            parsed['ranges'] = _.map(filteredArray, function (item) {
                min_val = parseFloat(item['Min NDVI']);
                max_val = parseFloat(item['Max NDVI']);
                return [moment.utc(item.Date).valueOf(), min_val, max_val];
            });

            Highcharts.chart('chart', {
                xAxis: {type: 'datetime'},
                title: {
                    text: 'NDVI for plot'
                },

                yAxis: {
                    title: {
                        text: 'NDVI'
                    }
                },

                series: [{
                    data: parsed["ndvi"],
                    tooltip: {
                        valueDecimals: 2
                    },
                    name: 'NDVI'
                },
                    {
                        data: parsed['ranges'],
                        type: 'arearange',
                        linkedTo: 'curve',
                        color: Highcharts.getOptions().colors[0],
                        fillOpacity: 0.3,
                        zIndex: 0,
                        name: 'Min/max',
                        tooltip: {
                            valueDecimals: 2
                        },
                        marker: {
                            enabled: false
                        }
                    }],
                plotOptions: {
                    series: {
                        cursor: 'pointer',
                        point: {
                            events: {
                                click: function () {
                                    mymap.removeLayer(image);
                                    geoj['properties']['layer_name'] = 'greece:' + moment(this.x).toDate().toISOString().split('T')[0];
                                    image = draw_image(geoj, boundary);
                                    overlays.push(image);
                                }
                            }
                        }
                    },
                    spline: {
                        marker: {
                            radius: 4,
                            lineColor: '#666666',
                            lineWidth: 1
                        }
                    }
                },

            });
        }


        let mymap = L.map('mapid').setView([40.063235, 22.449564], 11);
        let Esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        mymap.addLayer(Esri_WorldImagery);
        basemaps = {'Satellite': Esri_WorldImagery};

        let drawnItems = new L.FeatureGroup();
        mymap.addLayer(drawnItems);
        L.control.layers(basemaps).addTo(mymap);

        var drawControl = new L.Control.Draw({
            draw: {
                polygon: true,
                marker: false,
                polyline: false,
                circlemarker: false,
                circle: false
            },
            edit: {
                featureGroup: drawnItems,
                edit: false
            }
        });


        mymap.addControl(drawControl);

        mymap.on(L.Draw.Event.CREATED, function (e) {
            overlays.forEach(function (layer) {
                mymap.removeLayer(layer);
            });
            response = sync_get('layers/');
            if (response.status === 200) {
                ndvi_layer_list = JSON.parse(response.responseText)['ndvi'];
                ndwi_layer_list = JSON.parse(response.responseText)['ndwi'];
            } else {
                ndvi_layer_list = [];
                ndwi_layer_list = [];
            }

            let layer = e.layer;
            let geoj = layer.toGeoJSON();

            let stats = _.map(ndvi_layer_list, function (layer_name) {
                geoj['properties']['layer_name'] = layer_name;
                data = sync_post('ndvistats/', geoj);
                return data;
            });

            let filtered_stats = _.filter(stats, function (result) {
                if (result === {}) {
                    return result.ignore;
                }
                return result});

            if (filtered_stats.length === 0) {
                return;
            }
            make_chart(filtered_stats, geoj, layer._bounds);
            overlays.push(draw_image(geoj));
        });

        var legend = L.control({position: 'bottomright'});

        function getColor(color) {
            return sync_get('color/?color=' + color).responseText;
        }

        legend.onAdd = function (mymap) {

            var div = L.DomUtil.create('div', 'info legend'),
                grades = [0, 0.2, 0.4, 0.6, 0.8],
                labels = [];

            // loop through our density intervals and generate a label with a colored square for each interval
            for (var i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<i style="background:' + getColor(grades[i] + 0.1) + '"></i>' +
                    grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+');
            }

            return div;
        };

        legend.addTo(mymap);
    </script>

{% endblock %}